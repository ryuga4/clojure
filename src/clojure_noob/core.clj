(ns clojure-noob.core  (:gen-class)  )(defn -main  "I don't do a whole lot ... yet."  [& args]  (println "Hello, World!"))(defn train  []  (println "Choo choo!"))(println "Cleanliness is next to godliness")(reduce * [5 1 2 6 2 7])(defn silnia [n] (if (= n 1)   1) (* n (silnia (dec n))))(defn announce-treasure-location  [{lat :lat lng :lng}]  (println (str "Treasure lat: " lat))  (println (str "Treasure lng: " lng)))(announce-treasure-location {:lat 28.22 :lng 81.33})(defn fibbonaci-seq  ([] (fibbonaci-seq 0 1))  ([a b] (cons a (lazy-seq (fibbonaci-seq b (+ a b))))))(defn primes  ([] (primes [2] 3))    ([list n]   (let [list2 (take-while #(<= (* % %) n) list)]     (if (some #(zero? (rem n %)) list2)       (primes list (inc n))       (cons n (lazy-seq (primes (conj list n) (inc n)))))))) (def fib  (memoize (fn [n]            (case n              0 0N              1 1N              (+' (fib (dec n)) (fib (- n 2)))))))(defn fib2    ([n] (fib2 0 1 n))  ([r1 r2 r3] (loop [a r1 b r2 n r3]                      (if (zero? n) a (recur b (+' a b) (dec n))))))(defn my-case  ([e a] a)  ([e a b] (when (= e a) b))  ([e a b & rest]   (if (= e a) b (apply my-case (cons e rest)))))(defn times  [n f]  (apply f `())  (if (<= n 1) (apply f `()) (times (dec n) f)))(def options [[-2 0] [2 0] [0 2] [0 -2] [-2 -2] [2 2]])(defn tab-creator  [n]  (if (pos? n) (into (tab-creator (dec n)) [(range 1 (inc n))]) [])) (defn get-vec  [n vec]  (first (drop (dec n) vec)))(defn get-2  [y x l]  (when (and (pos? y) (pos? 0)) (get-vec y (get-vec x l))))(defn get-option-helper  [x y tab]  [(+ x (first tab)) (+ y (second tab))])(defn find-tab  [tab list]  (if (get-2 (second tab) (first tab) list)    [(get-2 (second tab) (first tab) list) (first tab)]))(defn jump-to  [x y list]  (filter #(not= nil %) (map                            #(find-tab % list)                            (map                              #(get-option-helper x y %)                              options))))(defmacro infix  [infixed]  (list (second infixed)         (first infixed)         (last infixed)))(defmacro println2  [expression]  (list 'let ['result expression]        (list 'println 'result)        'result)) (* 2/3 18/4)3N(defn silnia  [n]  (if (zero? n) 1 (* n (silnia (dec n)))))(silnia 5)    