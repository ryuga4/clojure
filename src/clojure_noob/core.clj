(ns clojure-noob.core  (:gen-class)  )(defn -main  "I don't do a whole lot ... yet."  [& args]  (println "Hello, World!"))(defn train  []  (println "Choo choo!"))(println "Cleanliness is next to godliness")(reduce * [5 1 2 6 2 7])(defn silnia [n] (if (= n 1)   1) (* n (silnia (dec n))))(defn announce-treasure-location  [{lat :lat lng :lng}]  (println (str "Treasure lat: " lat))  (println (str "Treasure lng: " lng)))(announce-treasure-location {:lat 28.22 :lng 81.33})(defn fibbonaci-seq  ([] (fibbonaci-seq 0 1))  ([a b] (cons a (lazy-seq (fibbonaci-seq b (+ a b))))))(defn primes  ([] (primes [2] 3))    ([list n]   (let [list2 (take-while #(<= (* % %) n) list)]     (if (some #(zero? (rem n %)) list2)       (primes list (inc n))       (cons n (lazy-seq (primes (conj list n) (inc n)))))))) (def fib  (memoize (fn [n]            (case n              0 0N              1 1N              (+' (fib (dec n)) (fib (- n 2)))))))(defn fib2    ([n] (fib2 0 1 n))  ([r1 r2 r3] (loop [a r1 b r2 n r3]                      (if (zero? n) a (recur b (+' a b) (dec n))))))(defn my-case  ([e a] a)  ([e a b] (when (= e a) b))  ([e a b & rest]   (if (= e a) b (apply my-case (cons e rest)))))(defn times  [n f]  (apply f `())  (if (<= n 1) (apply f `()) (times (dec n) f)))(defn field  [n]  (defn field2 [n]             (if (zero? n) `() (cons (replicate n :filled) (field2 (dec n)))))  (reverse (field2 n)))(defn half  [[x y]]  [[(/ x 2) (/ y 2)]])(def jumps [[2 0] [-2 0] [0 2] [0 -2] [2 2] [-2 -2]])(defn exist?  [y x tab]  (if (or (> y (count tab)) (<= y 0))    nil    (let [row (nth tab (dec y))]      (if (or (> x (count row)) (<= x 0))        nil        (nth row (dec x))))))(defn printTriangle  [tab]  (defn printTriangle2 [[head & tab] n]    (print (apply str (replicate (- n (count head)) " ")))    (println (apply str (map #(case %                                :filled "Â¤ "                                :empty "_ "                                "ER") head)))    (if (empty? tab) (println "") (printTriangle2 tab n)))  (printTriangle2 tab (count tab)))(defn main  []  (loop [x 1 y 2]    (println x)    (println y)    (recur (inc x) (dec y))))(defn posJumps  [y x tab [jump & jumps]]  (let [newx (+ (first jump) x) newy (+ (second jump) y)]    (if (empty? jumps) (list [[newx newy] [x y] (exist? newy newx tab)])        (cons [[newx newy] [x y] (exist? newy newx tab)] (posJumps y x tab jumps)))))(defn posOver  [[[newx newy] [x y] state]]  (if (nil? state) nil [(/ (+ newx x) 2) (/ (+ newy y) 2)]))(defn posOvers  [y x tab jumps]  (remove nil? (map posOver (posJumps y x tab jumps))))        